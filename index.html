<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>リッチテキストエディタ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#fffff9">
  <link rel="icon" href="icons/icon-192.png" type="image/png">
  <style>
    /* --- リセット --- */
    html, body {
      margin: 0; padding: 0;
    }
    body {
      font-family: sans-serif;
    }
    /* --- ヘッダー --- */
    #toolbar {
      padding: 8px;
      background: #f7f6f5;
      border-bottom: 1px solid #ccc;
      position: sticky; top: 0; z-index: 1000;
      display: flex; align-items: center; gap: 8px;
    }
    /* ヘッダーに残すボタン */
    #toolbar button, #toolbar input[type=file] {
      display: flex;
      margin-right: 4px;
    }
    /* --- コンテナ --- */
    #container {
      display: flex;
      height: calc(100vh - 50px);
    }
    /* --- サイドバー（アウトライン） --- */
    #sidebar {
      width: 200px;
      max-width: 500px;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      padding: 4px 8px;
      box-sizing: border-box;
      overflow-y: auto;
      position: relative;
      transition: width 0.2s ease;
    }
    #sidebar.hidden {
      width: 0;
      padding: 0;
      overflow: hidden;
    }
    #sidebar p{ font-size: 12px; color: #7d7d7d; }
    #outline { list-style:none; padding:0; margin:0; }
    #outline li { margin:0px 0; }
    #outline li.active > a { background:#ddd; }
    #outline .outline-item { text-decoration:none; font-size: 14px; color:#333333; display:block; padding:3px; border-radius:6px; cursor:pointer; margin: 2px 0px;}
    #outline .outline-item:hover { background:#f0f0f0; }
    #outline .outline-item.active { background:#e0e0e0;  font-weight:bold; }

    #toggleSidebar {
      position: static;
      top: 0.5em;
      leftt: 0.5em;
      width: 1.5em;
      height: 1.5em;
      border: 1px solid #999;
      border-radius: 0.25em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      visibility: visible !important;
    }

    #resizer {
      width: 5px;
      cursor: col-resize;
      background-color: transparent;
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
      z-index: 9;
    }

    /* --- エディタ領域 --- */
    #editor {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      position: relative;
      background-color: #fffff9;
    }
    /* リサイズ用コンテナ */
    .resizable-container {
      display: block;
      resize: both; overflow: auto;
      max-width: 100%;
      max-height: fit-content;
      margin:1em 0;
      border:1px dashed #ccc; position: relative;
    }
    .resizable-container img {
      width:100%; height:auto; display:block;
    }
    /* --- 浮動ツールバー --- */
    #float-toolbar {
      position: absolute;
      display: none;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      padding: 4px;
      z-index: 1001;
      display: flex;
      gap: 4px;
      align-items: center;
    }
    #float-toolbar button, #float-toolbar select {
      background: none;
      border: none;
      padding: 8px;
      cursor: pointer;
      font-size: 14px;
      border-radius: 3px;
    }
    #float-toolbar button:hover, #float-toolbar select:hover {
      background: #eee;
    }
    
    /* カラーピッカー関連 */
    .color-picker-container {
      position: relative;
      display: inline-block;
    }
    
    .color-picker {
      position: absolute;
      top: 100%;
      left: 0;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      display: none;
      z-index: 1002;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      grid-template-columns: repeat(5, 1fr);
      gap: 4px;
      min-width: 120px;
    }
    
    .color-picker.show {
      display: grid;
    }
    
    .color-option {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      cursor: pointer;
      border: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }
    
    .color-option:hover {
      border-color: #999;
      transform: scale(1.1);
    }
    
    #textColorBtn {
      color: #000;
      font-weight: bold;
      position: relative;
    }
    
    #textColorBtn::after {
      content: '';
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 2px;
      background: currentColor;
    }
  </style>
</head>
<body>

  <!-- ヘッダー：ファイル選択・保存のみ -->
  <div id="toolbar">
    <div id="toggleSidebar" title="折りたたみ">«</div>
    <input type="file" accept=".html" onchange="loadFile(event)" title="読み込み">
    <button onclick="saveAs()" title="名前を付けて保存 (Ctrl+S)">💾 名前を付けて保存</button>
    <span id="lastModified" style="margin-left: auto; font-size: 12px; color: #666;"></span>
  </div>

  <div id="container">
    <!-- アウトライン -->
    <div id="sidebar">
      <div id="resizer"></div>
      <P>アウトライン</P>
      <ul id="outline"></ul>
    </div>

    <!-- 編集領域 -->
    <div id="editor" contenteditable="true"
         ondrop="handleDrop(event)" ondragover="e=>e.preventDefault()">
      <h1>ここに文章を入力してください...</h1>
    </div>
  </div>

  <!-- 選択範囲浮動ツールバー -->
  <div id="float-toolbar">
    <button onclick="exec('bold')" title="太字">B</button>
    <button onclick="exec('italic')" title="斜体">I</button>
    <button onclick="exec('underline')" title="下線">U</button>
    <button onclick="exec('insertUnorderedList')" title="箇条書き">⋮≡</button>
    <button onclick="exec('insertOrderedList')" title="番号付きリスト">¹₂＝</button>
    <select onchange="exec('formatBlock', this.value)" title="見出し/段落">
      <option value="P">テキスト</option>
      <option value="H1">見出し1</option>
      <option value="H2">見出し2</option>
      <option value="H3">見出し3</option>
      <option value="H4">見出し4</option>
    </select>
    <div class="color-picker-container">
      <button onclick="toggleColorPicker('text')" title="文字色" id="textColorBtn">A</button>
      <div id="textColorPicker" class="color-picker">
        <div class="color-option" style="background-color: #24140e" onclick="setTextColor('#24140e')" title="ランプブラック"></div>
        <div class="color-option" style="background-color: #abb1b5" onclick="setTextColor('#abb1b5')" title="フォッグ"></div>
        <div class="color-option" style="background-color: #946c45" onclick="setTextColor('#946c45')" title="カフェオレ"></div>
        <div class="color-option" style="background-color: #f39800" onclick="setTextColor('#f39800')" title="マリーゴールド"></div>
        <div class="color-option" style="background-color: #e9bc00" onclick="setTextColor('#e9bc00')" title="トパーズ"></div>
        <div class="color-option" style="background-color: #578a3d" onclick="setTextColor('#578a3d')" title="アイビーグリーン"></div>
        <div class="color-option" style="background-color: #0068b7" onclick="setTextColor('#0068b7')" title="コバルトブルー"></div>
        <div class="color-option" style="background-color: #5a4498" onclick="setTextColor('#5a4498')" title="バイオレット"></div>
        <div class="color-option" style="background-color: #dc6b9a" onclick="setTextColor('#dc6b9a')" title="コスモス"></div>
        <div class="color-option" style="background-color: #ea5550" onclick="setTextColor('#ea5550')" title="ポピーレッド"></div>
      </div>
    </div>
    <div class="color-picker-container">
      <button onclick="toggleColorPicker('highlight')" title="ハイライト" id="highlightBtn">🖍</button>
      <div id="highlightColorPicker" class="color-picker">
        <div class="color-option" style="background-color: transparent; border: 1px solid #ccc" onclick="setHighlightColor('transparent')" title="クリア">×</div>
        <div class="color-option" style="background-color: #efefef" onclick="setHighlightColor('#efefef')" title="シルバーホワイト"></div>
        <div class="color-option" style="background-color: #f6e5cc" onclick="setHighlightColor('#f6e5cc')" title="エクルベージュ"></div>
        <div class="color-option" style="background-color: #fbd8b5" onclick="setHighlightColor('#fbd8b5')" title="ピーチ"></div>
        <div class="color-option" style="background-color: #fff3b8" onclick="setHighlightColor('#fff3b8')" title="クリームイエロー"></div>
        <div class="color-option" style="background-color: #f0f6da" onclick="setHighlightColor('#f0f6da')" title="ホワイトリリー"></div>
        <div class="color-option" style="background-color: #bbdbf3" onclick="setHighlightColor('#bbdbf3')" title="フロスティブルー"></div>
        <div class="color-option" style="background-color: #d1bada" onclick="setHighlightColor('#d1bada')" title="ライラック"></div>
        <div class="color-option" style="background-color: #e5c1cd" onclick="setHighlightColor('#e5c1cd')" title="ローズドラジェ"></div>
        <div class="color-option" style="background-color: #fbdac8" onclick="setHighlightColor('#fbdac8')" title="シェルピンク"></div>
      </div>
    </div>
  </div>

  <script>
  // PWA ServiceWorker 登録
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('service-worker.js');
  }

  let currentFilename = 'document.html';
  let lastModified = new Date(); // 最終更新日時
  const editor = document.getElementById('editor');
  const floatBar = document.getElementById('float-toolbar');
  
  // 選択範囲を保存するための変数（改善版）
  let savedSelection = null;
  let savedSelectionData = null;

  // アウトライン更新関数をグローバルスコープに定義
  function updateOutline() {
    const outline = document.getElementById('outline');
    outline.innerHTML = '';

    const headings = editor.querySelectorAll('h1, h2, h3, h4');
    headings.forEach((h, idx) => {
      const level = parseInt(h.tagName.substring(1));
      const link = document.createElement('div');
      link.textContent = h.textContent;
      link.style.marginLeft = (level - 1) * 16 + 'px';
      link.className = 'outline-item';
      link.dataset.headingIndex = idx; // 見出しのインデックスを保存
      link.onclick = () => {
        // スクロールして見出しを中央に表示
        h.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // 見出しにカーソル（キャレット）を移動
        const range = document.createRange();
        range.selectNodeContents(h);
        range.collapse(true);

        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        
        // アウトラインをハイライト
        updateOutlineHighlight();
      };
      outline.appendChild(link);
    });
    
    // 現在のカーソル位置に基づいてハイライトを更新
    updateOutlineHighlight();
  }

  // アウトラインのハイライトを更新する関数
  function updateOutlineHighlight() {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;

    const range = selection.getRangeAt(0);
    const currentElement = range.startContainer.nodeType === Node.TEXT_NODE 
      ? range.startContainer.parentElement 
      : range.startContainer;

    // 現在の要素から最も近い見出しを見つける
    let targetHeading = findCurrentOrPreviousHeading(currentElement);
    
    // 全てのアウトライン項目からactiveクラスを削除
    const outlineItems = document.querySelectorAll('.outline-item');
    outlineItems.forEach(item => item.classList.remove('active'));

    // 対象の見出しがある場合、対応するアウトライン項目をハイライト
    if (targetHeading) {
      const headings = editor.querySelectorAll('h1, h2, h3, h4');
      const headingIndex = Array.from(headings).indexOf(targetHeading);
      if (headingIndex >= 0) {
        const targetOutlineItem = document.querySelector(`[data-heading-index="${headingIndex}"]`);
        if (targetOutlineItem) {
          targetOutlineItem.classList.add('active');
        }
      }
    }
  }

  // 現在の要素または手前の見出しを見つける関数
  function findCurrentOrPreviousHeading(element) {
    // 現在の要素が見出しの場合はそれを返す
    if (element && element.matches && element.matches('h1, h2, h3, h4')) {
      return element;
    }

    // エディタ内の全ての要素を取得
    const allElements = Array.from(editor.querySelectorAll('*'));
    const currentIndex = allElements.indexOf(element);

    // 現在の要素から前方に向かって見出しを探す
    for (let i = currentIndex; i >= 0; i--) {
      const el = allElements[i];
      if (el.matches('h1, h2, h3, h4')) {
        return el;
      }
    }

    // 現在の要素の親要素から前方の兄弟要素を探す
    let current = element;
    while (current && current !== editor) {
      let prev = current.previousElementSibling;
      while (prev) {
        if (prev.matches('h1, h2, h3, h4')) {
          return prev;
        }
        // 前の要素の子要素内の見出しも確認
        const headingInPrev = prev.querySelector('h1, h2, h3, h4:last-of-type');
        if (headingInPrev) {
          return headingInPrev;
        }
        prev = prev.previousElementSibling;
      }
      current = current.parentElement;
    }

    return null;
  }

  // 選択範囲を保存する関数（改善版）
  function saveSelection() {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      savedSelection = range.cloneRange();
      
      // 追加の選択情報を保存
      savedSelectionData = {
        startContainer: range.startContainer,
        startOffset: range.startOffset,
        endContainer: range.endContainer,
        endOffset: range.endOffset,
        collapsed: range.collapsed
      };
    }
  }

  // 保存した選択範囲を復元する関数（改善版）
  function restoreSelection() {
    if (savedSelection) {
      try {
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(savedSelection);
        return true;
      } catch (e) {
        // Rangeが無効になった場合の代替処理
        if (savedSelectionData) {
          try {
            const range = document.createRange();
            range.setStart(savedSelectionData.startContainer, savedSelectionData.startOffset);
            range.setEnd(savedSelectionData.endContainer, savedSelectionData.endOffset);
            
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            return true;
          } catch (e2) {
            return false;
          }
        }
      }
    }
    return false;
  }

  // 標準コマンド実行
  function exec(cmd, val=null){
    document.execCommand(cmd, false, val);
    editor.focus();
    hideFloatBar();
  }

  // カラーピッカーの表示/非表示（改善版）
  function toggleColorPicker(type) {
    // 選択範囲を保存
    saveSelection();
    
    const pickerId = type === 'text' ? 'textColorPicker' : 'highlightColorPicker';
    const picker = document.getElementById(pickerId);
    const otherPicker = document.getElementById(type === 'text' ? 'highlightColorPicker' : 'textColorPicker');
    
    // 他のピッカーを閉じる
    otherPicker.classList.remove('show');
    
    // 現在のピッカーをトグル
    picker.classList.toggle('show');
    
    // ピッカーが開いた場合は、マウスイベントを防ぐ
    if (picker.classList.contains('show')) {
      picker.addEventListener('mousedown', function(e) {
        e.preventDefault();
      });
    }
  }

  // 文字色を設定（改善版）
  function setTextColor(color) {
    // 選択範囲を復元
    if (restoreSelection()) {
      // 即座にコマンドを実行
      const success = document.execCommand('foreColor', false, color);
      
      // 代替方法（一部のブラウザで必要）
      if (!success) {
        try {
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            if (!range.collapsed) {
              const span = document.createElement('span');
              span.style.color = color;
              try {
                range.surroundContents(span);
              } catch (e) {
                // 複雑な選択範囲の場合
                const contents = range.extractContents();
                span.appendChild(contents);
                range.insertNode(span);
              }
            }
          }
        } catch (e) {
        }
      }
    }
    
    // ボタンの色を更新
    document.getElementById('textColorBtn').style.color = color;
    
    // ピッカーを閉じる
    document.getElementById('textColorPicker').classList.remove('show');
    
    // エディタにフォーカスを戻す
    editor.focus();
    
    // 最終更新日時を更新
    updateLastModified();
  }

  // ハイライト色を設定（改善版）
  function setHighlightColor(color) {
    // 選択範囲を復元
    if (restoreSelection()) {
      if (color === 'transparent') {
        // ハイライトを削除
        document.execCommand('hiliteColor', false, 'transparent');
        document.execCommand('backColor', false, 'transparent');
      } else {
        // ハイライト色を設定
        let success = document.execCommand('hiliteColor', false, color);
        
        // Firefoxなど一部ブラウザ用の代替
        if (!success || !document.queryCommandSupported('hiliteColor')) {
          success = document.execCommand('backColor', false, color);
        }
        
        // 代替方法
        if (!success) {
          try {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
              const range = selection.getRangeAt(0);
              if (!range.collapsed) {
                const span = document.createElement('span');
                span.style.backgroundColor = color;
                try {
                  range.surroundContents(span);
                } catch (e) {
                  // 複雑な選択範囲の場合
                  const contents = range.extractContents();
                  span.appendChild(contents);
                  range.insertNode(span);
                }
              }
            }
          } catch (e) {
            console.warn('ハイライト色の設定に失敗しました:', e);
          }
        }
      }
    }
    
    // ピッカーを閉じる
    document.getElementById('highlightColorPicker').classList.remove('show');
    
    // エディタにフォーカスを戻す
    editor.focus();
    
    // 最終更新日時を更新
    updateLastModified();
  }

  // File System Access API がサポートされているかチェック
  function isFileSystemAccessSupported() {
    return 'showSaveFilePicker' in window;
  }

  // 最終更新日時を更新して表示
  function updateLastModified() {
    lastModified = new Date();
    displayLastModified();
  }

  // 最終更新日時を表示
  function displayLastModified() {
    const lastModifiedElement = document.getElementById('lastModified');
    const formatted = lastModified.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
    lastModifiedElement.textContent = `最終更新: ${formatted}`;
  }

  // 名前を付けて保存
  async function saveAs() {
    const content = editor.innerHTML;
    const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Document</title></head><body>${content}</body></html>`;

    if (isFileSystemAccessSupported()) {
      try {
        // File System Access API を使用してファイル選択ダイアログを表示
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: currentFilename,
          types: [{
            description: 'HTML files',
            accept: {'text/html': ['.html']},
          }],
        });

        const writable = await fileHandle.createWritable();
        await writable.write(html);
        await writable.close();

        // 保存されたファイルの情報を更新
        currentFilename = fileHandle.name;
        
        // 成功通知（オプション）
        showNotification(`${fileHandle.name} として保存しました`);
      } catch (error) {
        if (error.name !== 'AbortError') {
          // エラー時は従来の方法にフォールバック
          downloadFile(html, currentFilename);
        }
      }
    } else {
      // File System Access API が使用できない場合は従来の方法
      downloadFile(html, currentFilename);
    }
  }

  // 従来のダウンロード方式
  function downloadFile(content, filename) {
    const blob = new Blob([content], {type:'text/html'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // 通知表示（オプション）
  function showNotification(message) {
    // 簡単な通知を表示
    const notification = document.createElement('div');
    notification.textContent = message;
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #4CAF50;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 10000;
      font-size: 14px;
    `;
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.remove();
    }, 3000);
  }

  // 読み込み
  async function loadFile(e) {
    const f = e.target.files[0];
    if (!f) return;
    
    currentFilename = f.name;
    
    const r = new FileReader();
    r.onload = ev => {
      const tmp = document.createElement('div');
      tmp.innerHTML = ev.target.result;
      const b = tmp.querySelector('body');
      editor.innerHTML = b ? b.innerHTML : tmp.innerHTML;
      
      // ファイルの最終更新日時を設定
      lastModified = new Date(f.lastModified);
      displayLastModified();
      
      // ファイル読み込み後にアウトラインを更新
      updateOutline();
      showNotification(`${f.name} を読み込みました`);
    };
    r.readAsText(f);
    document.body.style.margin = '0';
    document.body.style.padding = '0';
  }

  // PWA ServiceWorker 登録（重複削除）
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js');
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    // Ctrl+S キーボードショートカットの追加
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveAs();
      }
    });

    // エディタの内容が変更されたときに最終更新日時を更新
    editor.addEventListener('input', () => {
      updateLastModified();
      updateOutline();
    });

    // アウトラインを自動更新
    editor.addEventListener('keydown', updateOutline);
    editor.addEventListener('mouseup', updateOutline);

    // 初期表示時に最終更新日時を表示
    displayLastModified();

    // カーソル位置変更時のハイライト更新
    editor.addEventListener('keyup', updateOutlineHighlight);
    editor.addEventListener('click', updateOutlineHighlight);
    document.addEventListener('selectionchange', () => {
      // selection変更がエディタ内で発生した場合のみ処理
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const container = range.commonAncestorContainer;
        if (editor.contains(container) || container === editor) {
          updateOutlineHighlight();
        }
      }
    });

    // サイドバーの折りたたみ
    const sidebar = document.getElementById('sidebar');
    const toggleSidebarBtn = document.getElementById('toggleSidebar');
    let sidebarWidth = 200; // デフォルト幅を保存
    
    toggleSidebarBtn.addEventListener('click', () => {
      if (sidebar.classList.contains('hidden')) {
        // 展開：保存された幅を復元
        sidebar.classList.remove('hidden');
        sidebar.style.width = sidebarWidth + 'px';
        toggleSidebarBtn.innerText = '«';
      } else {
        // 折りたたみ：現在の幅を保存してから非表示
        const currentWidth = sidebar.offsetWidth;
        if (currentWidth > 0) {
          sidebarWidth = currentWidth;
        }
        sidebar.classList.add('hidden');
        sidebar.style.width = '0px';
        toggleSidebarBtn.innerText = '☰';
      }
    });

    // サイドバー幅のリサイズ
    const resizer = document.getElementById('resizer');
    let isResizing = false;

    resizer.addEventListener('mousedown', (e) => {
      // 折りたたまれている場合はリサイズを無効化
      if (sidebar.classList.contains('hidden')) {
        return;
      }
      isResizing = true;
      document.body.style.cursor = 'col-resize';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing || sidebar.classList.contains('hidden')) return;
      
      const newWidth = Math.max(100, Math.min(500, e.clientX));
      sidebar.style.width = `${newWidth}px`;
      sidebarWidth = newWidth; // 幅を保存
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        document.body.style.cursor = 'default';
      }
    });

    // 初期化
    updateOutline();
  });

  // 画像ドロップ／挿入
  function handleDrop(e){
    e.preventDefault();
    Array.from(e.dataTransfer.files).forEach(file=>{
      if(file.type.startsWith('image/')){
        const reader = new FileReader();
        reader.onload=ev=>{
          const wrap = document.createElement('div');
          wrap.className='resizable-container';
          const img = document.createElement('img');
          img.src = ev.target.result;
          wrap.appendChild(img);
          insertAtCursor(wrap);
        };
        reader.readAsDataURL(file);
      }
    });
    updateOutline();
  }

  // カーソル位置にノード挿入
  function insertAtCursor(node){
    const sel = window.getSelection();
    if(!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    range.deleteContents();
    range.insertNode(node);
  }

  // 選択範囲時に浮動メニュー表示（改善版）
  document.addEventListener('mouseup', e=>{
    setTimeout(()=>{ // 選択反映待ち
      const sel = window.getSelection();
      
      if(sel.isCollapsed) { 
        hideFloatBar(); 
        return; 
      }
      
      // 選択範囲がエディタ内にあるかチェック
      const range = sel.getRangeAt(0);
      const container = range.commonAncestorContainer;
      
      // テキストノードの場合は親要素をチェック
      const containerElement = container.nodeType === Node.TEXT_NODE 
        ? container.parentElement 
        : container;
      
      // エディタ内の選択でない場合は非表示
      if (!editor.contains(containerElement) && containerElement !== editor) {
        hideFloatBar();
        return;
      }
      
      // 選択範囲を保存（浮動ツールバー表示時）
      saveSelection();
      
      // まず表示してサイズを取得
      floatBar.style.display = 'flex';
      floatBar.style.position = "absolute";
      floatBar.style.visibility = 'hidden'; // サイズ計算のため一時的に非表示
      
      const rect = range.getBoundingClientRect();
      const toolbarRect = floatBar.getBoundingClientRect();
      
      // 初期位置を設定（選択範囲の上中央）
      let top = rect.top - toolbarRect.height - 8;
      let left = rect.left + (rect.width / 2) - (toolbarRect.width / 2);
      
      // ビューポートの境界を取得
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // 左右の調整
      if (left < 10) {
        left = 10; // 左端から10px
      } else if (left + toolbarRect.width > viewportWidth - 10) {
        left = viewportWidth - toolbarRect.width - 10; // 右端から10px
      }
      
      // 上下の調整
      if (top < 10) {
        // 上にはみ出る場合は選択範囲の下に表示
        top = rect.bottom + 8;
      }
      
      if (top + toolbarRect.height > viewportHeight - 10) {
        // 下にはみ出る場合は再度上に調整
        top = rect.top - toolbarRect.height - 8;
        if (top < 10) {
          // それでも上にはみ出る場合は選択範囲と重なっても表示
          top = 10;
        }
      }
      
      // スクロール位置を考慮して最終位置を設定
      floatBar.style.top = (top + window.scrollY) + 'px';
      floatBar.style.left = (left + window.scrollX) + 'px';
      floatBar.style.visibility = 'visible'; // 表示
    }, 10);
  });

  // 非表示
  function hideFloatBar(){
    floatBar.style.display = 'none';
    // カラーピッカーも閉じる
    document.getElementById('textColorPicker').classList.remove('show');
    document.getElementById('highlightColorPicker').classList.remove('show');
  }

  // クリック時に消す（選択外）
  document.addEventListener('mousedown', e=>{
    if(!floatBar.contains(e.target)) {
      hideFloatBar();
    }
  });

  // エディタ以外でのselectionchange時は浮動ツールバーを隠す
  document.addEventListener('selectionchange', () => {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const container = range.commonAncestorContainer;
      const containerElement = container.nodeType === Node.TEXT_NODE 
        ? container.parentElement 
        : container;
      
      // エディタ外の選択の場合は浮動ツールバーを非表示
      if (!editor.contains(containerElement) && containerElement !== editor) {
        hideFloatBar();
      }
    } else {
      hideFloatBar();
    }
  });

  </script>

</body>
</html>